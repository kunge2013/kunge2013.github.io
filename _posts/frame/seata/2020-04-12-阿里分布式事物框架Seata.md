---
layout: post
title:  "seate入门"
date:   2020-04-12 23:06:06
categories: '分布式框架'
tags: seata
---

##### Seata 是什么?

Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。

Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。

---


##### AT 模式

######  前提

-   基于支持本地 ACID 事务的关系型数据库。
-   Java 应用，通过 JDBC 访问数据库。

###### 整体机制

两阶段提交协议的演变：

-   一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。

-   二阶段：

 	1. 提交异步化，非常快速地完成。
	2. 回滚通过一阶段的回滚日志进行反向补偿。
	
--- 	
 
##### 写隔离

-   一阶段本地事务提交前，需要确保先拿到 全局锁 。
-   拿不到 全局锁 ，不能提交本地事务。
-   拿 全局锁 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。

以一个示例来说明：

两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。

tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 全局锁 ，本地提交释放本地锁。 tx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 全局锁 ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 全局锁 。

<div align="left">  
<img src="https://kunge2013.github.io/images/jvm/写隔离1.png" width="600px"/>
</div>


tx1 二阶段全局提交，释放 全局锁 。tx2 拿到 全局锁 提交本地事务。

<div align="left">  
<img src="https://kunge2013.github.io/images/jvm/写隔离2.png" width="600px"/>
</div>


如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。

此时，如果 tx2 仍在等待该数据的 全局锁，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 全局锁 等锁超时，放弃 全局锁 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。

因为整个过程 全局锁 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 脏写 的问题。

